
## java内存结构分析--运行时数据区

 ### jdk1.7及以前的内存模型
 #### Method Area--所有线程共享的数据区
     常量池
     类静态变量
     类成员变量
     类的类型信息、构造函数、方法信息等。
 #### heap--所有线程共享的数据区
     存储java实例或者对象的地方，是GC的主要区域
 #### vm stack--线程隔离的数据区
     栈帧：当线程执行到某个方法时就会往方线程中压入一个栈帧。
     栈帧包含了方法的局部变量表，操作数栈，返回地址，动态链接等信息。
 #### native method stack--线程隔离的数据区
 #### program counter register--线程隔离的数据区

  *JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中
  开辟了一块区域存放运行时常量池。
  常量池：
    字面量：
      文本字符串
      被声明为final的常量值
      基本数据类型的值
      其他
    符号引用：
      类和结构的完全限定名
      子段名称和描述符
      方法名称和描述符
  
  *JDK 1.8 的时候，方法区（HotSpot的永久代）被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，元空间使用的是直接内存。
  下面是一些常用参数：
  -XX:MetaspaceSize=N //设置Metaspace的初始（和最小大小）
  -XX:MaxMetaspaceSize=N //设置Metaspace的最大大小
  与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。
  为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢?
  整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的
  限制，并且永远不会得到java.lang.OutOfMemoryError。你可以使用 -XX：MaxMetaspaceSize 标志设置最
  大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义
  元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。
  当然这只是其中一个原因，还有很多底层的原因，这里就不提了
  
 ### jdk1.8后的内存模型(说明1，线程隔离的数据区:只存在于线程的生命周期内，线程结束之后就会消失，不需要进行垃圾回收)
 #### Metaspace--直接内存
       类的加载信息 
 #### heap--所有线程共享的数据区
       存储java实例或者对象的地方，是GC的主要区域
       常量池
       静态变量
 #### vm stack--线程隔离的数据区
       每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、
       常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 
       虚拟机栈中入栈和出栈的过程。
       可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，
       在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：
       java -Xss2M HackTheJava
       该区域可能抛出以下异常：
       当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
       栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。
 #### native method stack--线程隔离的数据区
       本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本
       地方法服务。
       本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为
       基于本机硬件和操作系统的程序，对待这些方法需要特别处理。
 #### program counter register--线程隔离的数据区
       记录正在执行的虚拟机字节码指令的地址(如果正在执行的是本地方法则为空)

  * 程序计数器（Program Counter Register）是JVM中一块较小的内存区域，保
  存着当前线程执行的虚拟机字节码指令的内存地址。Java多线程的实现，其实是通
  过线程间的轮流切换并分配处理器执行时间的方式来实现的，在任何时刻，处理器
  都只会执行一个线程中的指令。在多线程场景下，为了保证线程切换回来后，还能
  恢复到原先状态，找到原先执行的指令，所以每个线程都会设立一个程序计数器，
  并且各个线程之间不会互相影响，程序计数器为"线程私有"的内存区域。
  如果当前线程正在执行Java方法，则程序计数器保存的是虚拟机字节码的内存地址，
  如果正在执行的是Native方法（非Java方法，JVM底层有许多非Java编写的函数
  实现），计数器则为空。程序计数器是唯一一个在Java规范中没有规定任何
  OutOfMemory场景的区域。
  
 ### 关于静态变量存放于heap还是metaspace
 public class c1{
 
     private static Long[] a = new Long[99999999];
     ......
     
     public static void main (String[]args){
          new C1();
     }
 }
 
 ### JVM的Client模式与Server模式
 JVM有两种运行模式Server与Client。两种模式的区别在于，
 Client模式启动速度较快，Server模式启动较慢；但是启动
 进入稳定期长期运行之后Server模式的程序运行速度比Client
 要快很多。这是因为Server模式启动的JVM采用的是重量级的虚
 拟机，对程序采用了更多的优化；而Client模式启动的JVM采用的
 是轻量级的虚拟机。所以Server启动慢，但稳定后速度比Client远远要快。
 