
### redis集群
 #### redis主从方案
 #### redis cluster方案
 #### codis集群方案
 #### 分析
    从各个集群方案的对比中我们也发现Codis是目前用的比较
    多的一种方案，Codis在高可用方面做的比较好，不需要重
    启节点和增加删除节点后自动Resharding，但是因为
    Codis是对redis-server做了改动，如果出现问题或者
    redis升级小团队可能应付不了，所以对于小规模应用最
    好还是使用官方的cluster方案，在redis3.0后官方社区
    也在逐步完善cluster方案，小团队可以随着官方版本的升
    级享受功能和稳定性的提升，也便于日后的维护。

### redis故障
 #### 雪崩
    对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 
    4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 
    个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，
    如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，
    但是数据库立马又被新的流量给打死了。
    
    解决方案：搭建redis高可用

 #### 穿透
    对于系统A，假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。
    黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。
    举个栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 
    全部都是负数。这样的话，缓存中不会有，请求每次都“视缓存于无物”，
    直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。
    
    解决方案：key是按照一定的规则设计的，当key是随机生成的不符合
    规则的过滤掉。当第一次到达的时候，给不存在的key设置一个默认值
    (例如一个空的字符串)，下次请求到达的时候就不会走db。
    
 #### 击穿
    缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的
    情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，
    就像是在一道屏障上凿开了一个洞。
    
### redis持久化

 #### RDB持久化
    优点:
    ·RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据 
    快照。非常适用于备份，全量复制等场景。比如每6小时执行bgsave备份，
    并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。
    ·Redis加载RDB恢复数据远远快于AOF的方式。
    
    缺点:
        RDB方式数据没办法做到实时持久化/秒级持久化。
        因为bgsave每次运 行都要执行fork操作创建子
        进程，属于重量级操作，频繁执行成本过高。
 #### AOF持久化
    1）AOF通过追加写命令到文件实现持久化，通过appendfsync参数
    可以 控制实时/秒级持久化。因为需要不断追加写命令，所以AOF文
    件体积逐渐变大，需要定期执行重写操作来降低文件体积。
    
    2）AOF重写可以通过auto-aof-rewrite-min-size和
    auto-aof-rewritepercentage参数控制自动触发，也
    可以使用bgrewriteaof命令手动触发。
    
    3）子进程执行期间使用copy-on-write机制与父进程共享
    内存，避免内 存消耗翻倍。AOF重写期间还需要维护重写缓
    冲区，保存新的写入命令避免数据丢失。