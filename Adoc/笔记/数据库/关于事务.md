## 本地事务
  ### 并发事务带来的问题
    在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的
    任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。
    
    **脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改
    还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。
    因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，
    依据“脏数据”所做的操作可能是不正确的。
    
    **丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问
    了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样
    第一个事务内的修改结果就被丢失，因此称为丢失修改。	例如：事务1读取某表中的数据
    A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务
    1的修改被丢失。
    
    **不可重复读（Unrepeatable read）: 指在一个事务内多次读同一数据。在这个事务还
    没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第
    二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两
    次读到的数据是不一样的情况，因此称为不可重复读。-侧重与update
    
    **幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几
    行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务
    （T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。-侧重于insert

  ### 事务隔离级别
    SQL标准定义了四个隔离级别：
    
    ** read uncommitted(读取未提交): 最低的隔离级别，允许读取尚未提交的数据变更，
    可能会导致脏读、幻读或不可重复读
    
    ** read committed(读取已提交): 允许读取并发事务已经提交的数据，可以阻止脏读，
    但是幻读或不可重复读仍有可能发生
    
    ** repeatable read(可重复读): 对同一字段的多次读取结果都是一致的，除非数据是被
    本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
    
    ** serializable(可串行化): 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次
    逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
    
    隔离级别	             脏读	不可重复读	幻影读
    read uncommitted	  √	       √	      √
    read committed        ×	       √	      √
    repeatable read       ×	       ×	      √
    serializable	      ×	       ×          ×

## 分布式事务
  ### 分布式事务的产生的原因
    1、数据库分库分表
    当数据库单表一年产生的数据超过1000W，那么就要考虑分库分表，
    具体分库分表的原理在此不做解释，以后有空详细说，简单的说就
    是原来的一个数据库变成了多个数据库。这时候，如果一个操作既
    访问01库，又访问02库，而且要保证数据的一致性，那么就要用到
    分布式事务。

    2、业务的服务化
    比如原来单机支撑了整个电商网站，现在对整个网站进行拆解，分
    离出了订单中心、用户中心、库存中心。对于订单中心，有专门
    的数据库存储订单信息，用户中心也有专门的数据库存储用户信息，
    库存中心也会有专门的数据库存储库存信息。这时候如果要同时对
    订单和库存进行操作，那么就会涉及到订单数据库和库存数据库，
    为了保证数据一致性，就需要用到分布式事务。
    
    以上两种情况表象不同，但是本质相同，都是因为要操作的数据库变多了！

   ### 分布式事务的应用场景
    1、支付
    最经典的场景就是支付了，一笔支付，是对买家账户进行扣款，同时对
    卖家账户进行加钱，这些操作必须在一个事务里执行，要么全部成功，
    要么全部失败。 而对于买家账户属于买家中心，对应的是买家数据库，
    而卖家账户属于卖家中心，对应的是卖家数据库，对不同数据库的操作
    必然需要引入分布式事务。
    
    2、在线下单
    买家在电商平台下单，往往会涉及到两个动作，一个是扣库存，第二个
    是更新订单状态，库存和订单一般属于不同的数据库，需要使用分布式
    事务保证数据一致性。

  ### 解决方法-本地消息表
    本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务
    来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证
    最终一致性。
    
    在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送
    一个消息，本地事务能保证这个消息一定会被写入本地消息表中。之后
    将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本
    地消息表中删除，否则继续重新转发。在分布式事务操作的另一方从消
    息队列中读取一个消息，并执行消息中的操作。
    